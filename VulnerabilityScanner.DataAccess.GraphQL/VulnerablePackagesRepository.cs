using VulnerabilityScanner.DataAccess.GraphQL.Interfaces;
using VulnerabilityScanner.DataAccess.Interfaces;
using VulnerabilityScanner.Models;

namespace VulnerabilityScanner.DataAccess.GraphQL;

public class VulnerablePackagesRepository : IVulnerablePackagesRepository
{
    private readonly IGraphQlClient _graphQlClient;
    private readonly IGraphQlRequestFactory _requestFactory;

    public VulnerablePackagesRepository(IGraphQlClient graphQlClient, IGraphQlRequestFactory requestFactory)
    {
        _graphQlClient = graphQlClient;
        _requestFactory = requestFactory;
    }

    public bool IsApplicable(ProjectEcosystem projectEcosystem) =>
        projectEcosystem == ProjectEcosystem.Npm;

    public Task<VulnerablePackage?> GetVulnerablePackageAsync(
        ProjectEcosystem ecosystem,
        string packageName,
        CancellationToken cancellationToken)
    {
        return GetVulnerablePackageInternalAsync<VulnerablePackage>(ecosystem, packageName, cancellationToken);
    }

    public async Task<IEnumerable<VulnerablePackage>> GetVulnerablePackagesAsync(
        ProjectEcosystem ecosystem,
        IEnumerable<string> packagesNames,
        CancellationToken cancellationToken)
    {
        var gettingVulnerablePackagesTaskList = packagesNames
            .Select(x => GetVulnerablePackageInternalAsync<IEnumerable<VulnerablePackage>>(ecosystem, x, cancellationToken))
            .ToList();

         await Task.WhenAll(gettingVulnerablePackagesTaskList);

         return gettingVulnerablePackagesTaskList
             .Where(x => x.Result is not null)
             .SelectMany(x => x.Result!);
    }

    private Task<T?> GetVulnerablePackageInternalAsync<T>(
        ProjectEcosystem ecosystem,
        string packageName,
        CancellationToken cancellationToken)
    {
        var request = _requestFactory.CreateSecurityVulnerableRequest(ecosystem, packageName);
        return _graphQlClient.ExecuteAsync<T>(request, cancellationToken);
    }
}
