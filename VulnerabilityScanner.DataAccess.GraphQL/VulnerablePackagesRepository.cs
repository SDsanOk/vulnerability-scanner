using VulnerabilityScanner.Models;

namespace VulnerabilityScanner.DataAccess.GraphQL;

public class VulnerablePackagesRepository : IVulnerablePackagesRepository
{
    private readonly IGraphQlClient _graphQlClient;
    private readonly IGraphQlRequestFactory _requestFactory;

    public VulnerablePackagesRepository(IGraphQlClient graphQlClient, IGraphQlRequestFactory requestFactory)
    {
        _graphQlClient = graphQlClient;
        _requestFactory = requestFactory;
    }

    public Task<VulnerablePackage?> GetVulnerablePackageAsync(
        ProjectEcosystem ecosystem,
        string packageName,
        CancellationToken cancellationToken)
    {
        return GetVulnerablePackageInternalAsync(ecosystem, packageName, cancellationToken);
    }

    public async Task<IEnumerable<VulnerablePackage>> GetVulnerablePackagesAsync(
        ProjectEcosystem ecosystem,
        IEnumerable<string> packagesNames,
        CancellationToken cancellationToken)
    {
        var gettingVulnerablePackagesTaskList = packagesNames
            .Select(x => GetVulnerablePackageInternalAsync(ecosystem, x, cancellationToken))
            .ToList();

         await Task.WhenAll(gettingVulnerablePackagesTaskList);

         return gettingVulnerablePackagesTaskList
             .Select(x => x.Result)
             .Where(x => x is not null)!;
    }

    private Task<VulnerablePackage?> GetVulnerablePackageInternalAsync(
        ProjectEcosystem ecosystem,
        string packageName,
        CancellationToken cancellationToken)
    {
        var request = _requestFactory.CreateSecurityVulnerableRequest(ecosystem, packageName);
        return _graphQlClient.ExecuteAsync<VulnerablePackage>(request, cancellationToken);
    }
}

public interface IVulnerablePackagesRepository
{
    Task<IEnumerable<VulnerablePackage>> GetVulnerablePackagesAsync(
        ProjectEcosystem ecosystem,
        IEnumerable<string> packagesNames,
        CancellationToken cancellationToken);
}
