using VulnerabilityScanner.DataAccess.Interfaces;
using VulnerabilityScanner.Domain.Interfaces;
using VulnerabilityScanner.Models;

namespace VulnerabilityScanner.Domain;

public class VulnerablePackagesProvider : IVulnerablePackagesProvider
{
    private readonly IEnumerable<IVulnerablePackagesRepository> _vulnerablePackagesRepositories;

    public VulnerablePackagesProvider(IEnumerable<IVulnerablePackagesRepository> vulnerablePackagesRepositories)
    {
        _vulnerablePackagesRepositories = vulnerablePackagesRepositories;
    }

    public async Task<IEnumerable<VulnerablePackage>> GetVulnerablePackagesAsync(
        Project project,
        CancellationToken cancellationToken)
    {
        var suitablePackageRepository = _vulnerablePackagesRepositories.FirstOrDefault(x => x.IsApplicable(project.Ecosystem));
        if (suitablePackageRepository is null)
        {
            throw new Exception($"Can't find suitable repository for {project.Ecosystem} ecosystem");
        }

        var packagesVersionsDictionary = project
            .ProjectDependencies
            .ToDictionary(key => key.Name, value => value.Version);
        var vulnerablePackages = await suitablePackageRepository.GetVulnerablePackagesAsync(
            project.Ecosystem,
            packagesVersionsDictionary.Keys,
            cancellationToken);

        var vulnerablePackagesList = vulnerablePackages.ToList();
        foreach (var vulnerablePackage in vulnerablePackagesList)
        {
            if (packagesVersionsDictionary.TryGetValue(vulnerablePackage.Name, out var packageVersion))
            {
                vulnerablePackage.Version = packageVersion;
            }
        }

        return vulnerablePackagesList;
    }
}
