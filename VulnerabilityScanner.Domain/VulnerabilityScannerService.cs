using VulnerabilityScanner.Domain.Interfaces;
using VulnerabilityScanner.Models;
using VulnerabilityScanner.Models.Enums;

namespace VulnerabilityScanner.Domain;

public class VulnerabilityScannerService : IVulnerabilityScannerService
{
    private readonly IVulnerablePackagesProvider _vulnerablePackagesProvider;
    private readonly IVulnerablePackagesVersionFilter _packagesVersionFilter;

    public VulnerabilityScannerService(
        IVulnerablePackagesProvider vulnerablePackagesProvider,
        IVulnerablePackagesVersionFilter packagesVersionFilter)
    {
        _vulnerablePackagesProvider = vulnerablePackagesProvider;
        _packagesVersionFilter = packagesVersionFilter;
    }

    public async Task<IEnumerable<VulnerablePackage>> ScanProjectVulnerabilitiesAsync(
        Project project,
        CancellationToken cancellationToken)
    {
        var vulnerablePackages = await _vulnerablePackagesProvider.GetVulnerablePackagesAsync(project, cancellationToken);
        var filteredVulnerablePackages = _packagesVersionFilter.FilterPackagesByVersions(vulnerablePackages);

        return filteredVulnerablePackages;
    }

    private bool IsVersionMatch(Version packageVersion, VulnerableVersionRange vulnerableVersionRange)
    {
        var vulnerableVersion = vulnerableVersionRange.Version;
        return vulnerableVersionRange.Operator switch
        {
            EqualityOperator.LessOrEqual => packageVersion <= vulnerableVersion,
            EqualityOperator.Less => packageVersion < vulnerableVersion,
            EqualityOperator.GreaterOrEqual => packageVersion >= vulnerableVersion,
            EqualityOperator.Greater => packageVersion > vulnerableVersion,
            EqualityOperator.Equal => packageVersion == vulnerableVersion,
            _ => throw new ArgumentOutOfRangeException()
        };
    }
}
