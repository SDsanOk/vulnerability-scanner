using AutoFixture;
using AutoFixture.Xunit2;
using FluentAssertions;
using VulnerabilityScanner.DataAccess.GraphQL.Models;
using VulnerabilityScanner.Models;
using Xunit;

namespace VulnerabilityScanner.DataAccess.GraphQL.Tests.DeserializingVulnerablePackages;

public class WhenVulnerabilitiesPresented : VulnerablePackagesDeserializerStrategyFixture
{
    [Theory]
    [AutoData]
    public void ReturnCorrectVulnerabilities(IEnumerable<SecurityVulnerability> securityVulnerabilities)
    {
        var securityVulnerabilitiesList = securityVulnerabilities.ToList();
        securityVulnerabilitiesList.ForEach(x => x.Severity = "LOW");
        var vulnerableRange = Fixture.Create<VulnerableVersionRange>();
        WithVulnerableVersionRange(vulnerableRange);

        var result = Subject
            .Deserialize(GenerateVulnerabilitiesJson(securityVulnerabilitiesList))
            .ToList();

        for (int i = 0; i < securityVulnerabilitiesList.Count; i++)
        {
            var resultVulnerability = result[i];
            var originalVulnerability = securityVulnerabilitiesList[i];

            AssertVulnerabilities(resultVulnerability, originalVulnerability, vulnerableRange);
        }
    }

    private void AssertVulnerabilities(
        VulnerablePackage resultVulnerability,
        SecurityVulnerability originalVulnerability,
        VulnerableVersionRange vulnerableRange)
    {
        resultVulnerability.Severity.Should().Be(VulnerabilitySeverity.Low);
        resultVulnerability.Name.Should().Be(originalVulnerability.Package.Name);
        resultVulnerability.Summary.Should().Be(originalVulnerability.Advisory.Summary);
        resultVulnerability.FirstPatchedVersion.Should().Be(originalVulnerability.FirstPatchedVersion.Identifier);
        resultVulnerability.VulnerableVersionRanges.Should().AllBeEquivalentTo(vulnerableRange);
    }
}
